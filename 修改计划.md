我现在想要验证属性数据的一个性质：属性标签之间会有一些类似“聚合”的关系，也就是说，有些属性会天然的更倾向于出现在同一个向量上。

我想利用这个性质，去修改filtered-diskann的代码，具体做法就是在alpha的基础上再加一个β变量，先是维护一个数据结构去统计属性标签之间的相关性，也就是统计两个属性出现在同一个向量上的概率，然后普通的diskann做法是dis(p,p')/dis(p*,p')>alpha则剪枝，而我想要$dis(p,p')/dis(p'',p')>alpha\times β$，所以两个向量的标签相关度比较高则β>1且较大，否则β<1且较小，这样可以让整个图变的更佳优秀。

还有一个要求，就是当两个属性都和对方在同一个向量上出现的概率比较大时在会让β增加，因为这样要避免某个属性很火，它和其他的很多属性出现在同一个向量上，比如2025年这个标签，非常多的论文都挂2025的属性，但是2025平均的被很多属性共享，这就不能影响β，所以影响β变大的因素必须是双向的。



我准备在diskann的基础上去修改，下面是gemini 2.5 pro根据我的需求生成的方案：



好的，根据我们之前的讨论和您完善后的需求，这是一个完整的、纯文字的规划，旨在指导您如何在Filtered-DiskANN项目中实现基于标签“双向”相关性的动态剪枝功能。



### **项目目标**



增强Filtered-DiskANN的图构建算法，引入一个由标签语义相关性决定的`β`因子，动态调整Vamana算法的剪枝阈值。此举旨在保留语义上强关联的边，同时避免因“热门标签”导致图结构失衡，最终提升过滤搜索的效率和召回率。

------



### **完整实施规划**



此规划分为四个主要阶段，从高层配置到底层算法修改，循序渐进。



#### **阶段一：功能配置与结构准备**



此阶段的目标是为新功能建立基础框架，使其可配置、可开关。

1. **定义用户可调参数**：
   - 在项目的索引构建参数配置中（逻辑上对应于`index_build_params.h`文件），添加两个新的参数：
     - `use_label_correlation` (布尔型): 作为新功能的总开关，默认为`false`。
     - `beta_strength` (浮点型): 用于控制`β`因子的影响强度，默认为`1.0`。这个参数让您可以调整相关性分数对剪枝力度的影响大小。
2. **扩展索引类结构**：
   - 在核心的`Index`类定义中（逻辑上对应于`index.h`文件），添加相应的私有成员变量来存储上述两个参数。
   - 同时，在`Index`类中定义一个新的私有成员变量，用于存储预计算的标签相关性分数。推荐使用嵌套哈希表（如`unordered_map`）的结构，即`_label_correlation_matrix`，它可以高效地存储和查询任意两个标签之间的相关性得分。
3. **初始化参数**：
   - 在`Index`类的构造函数中，从传入的构建参数中读取`use_label_correlation`和`beta_strength`的值，并初始化对应的成员变量。



#### **阶段二：计算“双向”标签相关性**



此阶段是实现您核心需求的关键，即计算能抵抗“热门标签”偏差的相关性分数。

1. **选择相关性度量指标**：
   - 为了满足“影响β变大的因素必须是双向的”这一要求，我们将采用**Ochiai系数**（也称几何平均或余弦相似度）。
   - **公式**: `相关性(A, B) = A与B的共现次数 / sqrt(A的总出现次数 * B的总出现次数)`
   - 这个指标天然地满足对称性，并且只有当两个标签对于彼此都显得重要时，得分才会高，完美解决了您提出的“热门标签”问题。
2. **设计计算流程**：
   - 在`Index`类中创建一个新的私有方法，例如`calculate_label_correlations()`。
   - 此方法的执行时机应在索引构建过程中**加载完所有标签数据之后、正式开始建图（linking）之前**。最佳的调用位置是在`build_filtered_index`函数内部，紧随标签文件解析完成之后。
3. **实现计算逻辑**：
   - **数据统计**: 首先，遍历整个数据集的所有点，统计两个关键信息：1）每个独立标签的总出现次数；2）每一对标签在同一个向量上共同出现的次数。
   - **分数计算**: 其次，遍历所有共现过的标签对，利用Ochiai系数公式计算它们之间的相关性分数（一个0到1之间的浮点数）。
   - **填充矩阵**: 最后，将计算出的分数存入在阶段一中创建的`_label_correlation_matrix`中，确保为每一对`(A, B)`和`(B, A)`存储相同的值以保证对称性。



#### **阶段三：集成到核心剪枝算法**



此阶段将把计算出的相关性分数应用到图构建的核心剪枝逻辑中。

1. **定位修改点**：
   - 核心修改将发生在`occlude_list`函数内部，这是Vamana算法执行遮挡剪枝的地方。具体位置是在判断是否要用一个近邻`N1`来剪掉一个远邻`N2`的循环内部。
2. **实现动态`beta`因子**：
   - 在原有的剪枝判断逻辑之前，插入一段新的逻辑。
   - **检查开关**: 首先检查`use_label_correlation`开关是否为`true`。
   - **获取标签**: 如果开关开启，则获取当前正在比较的两个节点（`N1`和`N2`）各自的标签列表。
   - **查询分数**: 查询预计算好的`_label_correlation_matrix`，找出`N1`的标签集与`N2`的标签集之间所有标签对相关性分数的**最大值**。这个最大值将作为这两个节点语义相关性的代表。
   - **计算`beta`**: 将这个最大相关性分数（范围[0, 1]）通过一个函数映射为`beta`因子。例如，可以设计一个线性映射，使得相关性为0.5时`beta`为1.0（基准），相关性为1.0时`beta`最大（如`1.0 + beta_strength`），相关性为0.0时`beta`最小（如`1.0 - beta_strength`）。
3. **应用`beta`调整剪枝阈值**：
   - 在计算`N1`和`N2`之间的几何距离`djk`之后，用`beta`来调整这个距离，得到一个“语义调整后的有效距离”`djk_beta`。
   - **调整公式**: `djk_beta = djk / beta`。
   - **效果**: 当`beta > 1`（强相关）时，有效距离变短，这会导致`occlude_factor`的值增大，使得这条边更难被剪枝，从而被保留下来。反之，当`beta < 1`（不相关）时，有效距离变长，更容易被剪枝。
   - 使用这个`djk_beta`来完成后续的`occlude_factor`计算，从而无缝地将您的想法集成到现有算法中。



#### **阶段四：验证与测试**



1. **命令行扩展 (可选)**: 为了方便实验，可以修改命令行工具的接口，允许通过命令行参数直接设置`use_label_correlation`和`beta_strength`。
2. **效果验证**: 在相同数据集和`alpha`参数下，分别在开启和关闭新功能的情况下构建索引。通过比较两种索引在特定过滤查询任务下的召回率、查询延迟（QPS）和平均度数等指标，来量化评估您的改进带来的效果。

通过以上四个阶段的规划，您可以系统性地在DiskANN项目中实现您的创新想法，并对其效果进行科学的验证。

